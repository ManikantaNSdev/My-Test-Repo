name: Deploy to NetSuite with JWT

on:
  push:
    branches: [main]
    paths:
      - 'multiplier-netsuite-integration/src/FileCabinet/SuiteScripts/**.js'  # Trigger on any JavaScript file changes in SuiteScripts folder or subfolders
      - '.github/workflows/deploy-to-netsuite.yml'  # Also trigger when workflow file changes
  workflow_dispatch:  # Allow manual triggering

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '16'
      
      - name: Create package.json if not exists
        run: |
          if [ ! -f package.json ]; then
            echo '{
              "name": "netsuite-deployment-automation",
              "version": "1.0.0",
              "dependencies": {
                "axios": "^1.9.0",
                "crypto": "^1.0.1",
                "dotenv": "^16.5.0",
                "form-data": "^4.0.3",
                "jsonwebtoken": "^9.0.2",
                "oauth-1.0a": "^2.2.6"
              }
            }' > package.json
          fi
      
      - name: Install dependencies
        run: npm install
      
      - name: Create deployment script
        run: |
          cat > multiplier_netsuite_deployment.js << 'EOF'
          /**
           * Multiplier NetSuite Deployment System
           * Syncs JavaScript files from GitHub to NetSuite while preserving folder structure
           * Also creates script records based on script type annotations
           */

          require('dotenv').config();
          const fs = require('fs');
          const axios = require('axios');
          const path = require('path');
          const crypto = require('crypto');

          // NetSuite API Configuration
          const BASE_URL = process.env.BASE_URL;
          const SOAP_URL = `${BASE_URL}/services/NetSuitePort_2024_1`;

          // Deployment Configuration
          const SOURCE_ROOT = './multiplier-netsuite-integration/src/FileCabinet/SuiteScripts';  // GitHub repo root folder for SuiteScripts
          
          // NetSuite folder IDs - can be configured via environment variables
          const FOLDER_IDS = {
            'SuiteScripts': process.env.NETSUITE_SUITESCRIPTS_FOLDER_ID || '2746719',
            'SuiteScripts/Restlet Scripts': process.env.NETSUITE_RESTLET_FOLDER_ID || '2747420',
            // Add more folder mappings as needed
          };

          // NetSuite folder paths mapping (GitHub path to NetSuite path)
          const FOLDER_PATH_MAPPING = {
            'multiplier-netsuite-integration/src/FileCabinet/SuiteScripts': 'SuiteScripts',
            'multiplier-netsuite-integration/src/FileCabinet/SuiteScripts/Restlet Scripts': 'SuiteScripts/Restlet Scripts',
            // Add more path mappings as needed
          };

          // Script type mapping
          const SCRIPT_TYPES = {
            'restlet': 'scriptrestlet',
            'suitelet': 'scriptsuitelet',
            'scheduled': 'scheduledscript',
            'mapreduce': 'mapreducescript',
            'userevent': 'usereventscript',
            'client': 'clientscript',
            'workflowaction': 'workflowactionscript',
            'portlet': 'scriptportlet',
            'massupdate': 'massupdatescript',
            'bundleinstallation': 'bundleinstallationscript'
          };

          // Generate OAuth 1.0 signature for NetSuite Token-Based Authentication
          function generateOAuth1Signature(timestamp, nonce) {
            const baseString = `${process.env.ACCOUNT_ID}&${process.env.CONSUMER_KEY}&${process.env.TOKEN_ID}&${nonce}&${timestamp}`;
            const signingKey = `${process.env.CONSUMER_SECRET}&${process.env.TOKEN_SECRET}`;
            return crypto.createHmac('sha256', signingKey).update(baseString).digest('base64');
          }

          // Generate SOAP envelope to search for existing files
          function generateSearchSOAP(fileName, folderId) {
            const timestamp = Math.floor(Date.now() / 1000);
            const nonce = crypto.randomBytes(16).toString('hex');
            const signature = generateOAuth1Signature(timestamp, nonce);

            return `<?xml version="1.0" encoding="UTF-8"?>
          <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" 
                         xmlns:mes="urn:messages_2024_1.platform.webservices.netsuite.com" 
                         xmlns:core="urn:core_2024_1.platform.webservices.netsuite.com"
                         xmlns:fil="urn:filecabinet_2024_1.documents.webservices.netsuite.com">
            <soap:Header>
              <mes:tokenPassport>
                <core:account>${process.env.ACCOUNT_ID}</core:account>
                <core:consumerKey>${process.env.CONSUMER_KEY}</core:consumerKey>
                <core:token>${process.env.TOKEN_ID}</core:token>
                <core:nonce>${nonce}</core:nonce>
                <core:timestamp>${timestamp}</core:timestamp>
                <core:signature algorithm="HMAC-SHA256">${signature}</core:signature>
              </mes:tokenPassport>
            </soap:Header>
            <soap:Body>
              <mes:search>
                <mes:searchRecord xsi:type="fil:FileSearch" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                  <fil:basic>
                    <core:name operator="is">
                      <core:searchValue>${fileName}</core:searchValue>
                    </core:name>
                    <core:folder operator="anyOf">
                      <core:searchValue internalId="${folderId}"/>
                    </core:folder>
                  </fil:basic>
                </mes:searchRecord>
              </mes:search>
            </soap:Body>
          </soap:Envelope>`;
          }

          // Generate SOAP envelope for file upload (add)
          function generateAddSOAP(fileName, base64Content, folderId) {
            const timestamp = Math.floor(Date.now() / 1000);
            const nonce = crypto.randomBytes(16).toString('hex');
            const signature = generateOAuth1Signature(timestamp, nonce);

            return `<?xml version="1.0" encoding="UTF-8"?>
          <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" 
                         xmlns:mes="urn:messages_2024_1.platform.webservices.netsuite.com" 
                         xmlns:core="urn:core_2024_1.platform.webservices.netsuite.com"
                         xmlns:fil="urn:filecabinet_2024_1.documents.webservices.netsuite.com">
            <soap:Header>
              <mes:tokenPassport>
                <core:account>${process.env.ACCOUNT_ID}</core:account>
                <core:consumerKey>${process.env.CONSUMER_KEY}</core:consumerKey>
                <core:token>${process.env.TOKEN_ID}</core:token>
                <core:nonce>${nonce}</core:nonce>
                <core:timestamp>${timestamp}</core:timestamp>
                <core:signature algorithm="HMAC-SHA256">${signature}</core:signature>
              </mes:tokenPassport>
            </soap:Header>
            <soap:Body>
              <mes:add>
                <mes:record xsi:type="fil:File" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                  <fil:name>${fileName}</fil:name>
                  <fil:content>${base64Content}</fil:content>
                  <fil:fileType>_JAVASCRIPT</fil:fileType>
                  <fil:folder internalId="${folderId}"/>
                </mes:record>
              </mes:add>
            </soap:Body>
          </soap:Envelope>`;
          }

          // Generate SOAP envelope for file update
          function generateUpdateSOAP(fileId, fileName, base64Content) {
            const timestamp = Math.floor(Date.now() / 1000);
            const nonce = crypto.randomBytes(16).toString('hex');
            const signature = generateOAuth1Signature(timestamp, nonce);

            return `<?xml version="1.0" encoding="UTF-8"?>
          <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" 
                         xmlns:mes="urn:messages_2024_1.platform.webservices.netsuite.com" 
                         xmlns:core="urn:core_2024_1.platform.webservices.netsuite.com"
                         xmlns:fil="urn:filecabinet_2024_1.documents.webservices.netsuite.com">
            <soap:Header>
              <mes:tokenPassport>
                <core:account>${process.env.ACCOUNT_ID}</core:account>
                <core:consumerKey>${process.env.CONSUMER_KEY}</core:consumerKey>
                <core:token>${process.env.TOKEN_ID}</core:token>
                <core:nonce>${nonce}</core:nonce>
                <core:timestamp>${timestamp}</core:timestamp>
                <core:signature algorithm="HMAC-SHA256">${signature}</core:signature>
              </mes:tokenPassport>
            </soap:Header>
            <soap:Body>
              <mes:update>
                <mes:record xsi:type="fil:File" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" internalId="${fileId}">
                  <fil:name>${fileName}</fil:name>
                  <fil:content>${base64Content}</fil:content>
                  <fil:fileType>_JAVASCRIPT</fil:fileType>
                </mes:record>
              </mes:update>
            </soap:Body>
          </soap:Envelope>`;
          }

          // Parse script file to extract script type and API version
          function parseScriptFile(fileContent) {
            const apiVersionMatch = fileContent.match(/@NApiVersion\s+(\d+\.\d+)/);
            const scriptTypeMatch = fileContent.match(/@NScriptType\s+(\w+)/i);
            
            return {
              apiVersion: apiVersionMatch ? apiVersionMatch[1] : null,
              scriptType: scriptTypeMatch ? scriptTypeMatch[1].toLowerCase() : null
            };
          }

          // Generate SOAP envelope to search for existing script record
          function generateScriptSearchSOAP(scriptName) {
            const timestamp = Math.floor(Date.now() / 1000);
            const nonce = crypto.randomBytes(16).toString('hex');
            const signature = generateOAuth1Signature(timestamp, nonce);

            return `<?xml version="1.0" encoding="UTF-8"?>
          <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" 
                         xmlns:mes="urn:messages_2024_1.platform.webservices.netsuite.com" 
                         xmlns:core="urn:core_2024_1.platform.webservices.netsuite.com"
                         xmlns:plat="urn:core_2024_1.platform.webservices.netsuite.com">
            <soap:Header>
              <mes:tokenPassport>
                <core:account>${process.env.ACCOUNT_ID}</core:account>
                <core:consumerKey>${process.env.CONSUMER_KEY}</core:consumerKey>
                <core:token>${process.env.TOKEN_ID}</core:token>
                <core:nonce>${nonce}</core:nonce>
                <core:timestamp>${timestamp}</core:timestamp>
                <core:signature algorithm="HMAC-SHA256">${signature}</core:signature>
              </mes:tokenPassport>
            </soap:Header>
            <soap:Body>
              <mes:search>
                <mes:searchRecord xsi:type="plat:ScriptSearch" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                  <plat:basic>
                    <plat:name operator="is">
                      <plat:searchValue>${scriptName}</plat:searchValue>
                    </plat:name>
                  </plat:basic>
                </mes:searchRecord>
              </mes:search>
            </soap:Body>
          </soap:Envelope>`;
          }

          // Generate SOAP envelope to create a script record
          function generateAddScriptSOAP(scriptName, scriptType, fileId, apiVersion) {
            const timestamp = Math.floor(Date.now() / 1000);
            const nonce = crypto.randomBytes(16).toString('hex');
            const signature = generateOAuth1Signature(timestamp, nonce);
            
            const nsScriptType = SCRIPT_TYPES[scriptType] || scriptType;
            
            return `<?xml version="1.0" encoding="UTF-8"?>
          <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" 
                         xmlns:mes="urn:messages_2024_1.platform.webservices.netsuite.com" 
                         xmlns:core="urn:core_2024_1.platform.webservices.netsuite.com"
                         xmlns:plat="urn:core_2024_1.platform.webservices.netsuite.com">
            <soap:Header>
              <mes:tokenPassport>
                <core:account>${process.env.ACCOUNT_ID}</core:account>
                <core:consumerKey>${process.env.CONSUMER_KEY}</core:consumerKey>
                <core:token>${process.env.TOKEN_ID}</core:token>
                <core:nonce>${nonce}</core:nonce>
                <core:timestamp>${timestamp}</core:timestamp>
                <core:signature algorithm="HMAC-SHA256">${signature}</core:signature>
              </mes:tokenPassport>
            </soap:Header>
            <soap:Body>
              <mes:add>
                <mes:record xsi:type="plat:Script" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                  <plat:name>${scriptName}</plat:name>
                  <plat:scriptType>${nsScriptType}</plat:scriptType>
                  <plat:scriptFile internalId="${fileId}"/>
                  <plat:apiVersion>${apiVersion}</plat:apiVersion>
                </mes:record>
              </mes:add>
            </soap:Body>
          </soap:Envelope>`;
          }

          // Generate SOAP envelope to update a script record
          function generateUpdateScriptSOAP(scriptId, scriptName, fileId, apiVersion) {
            const timestamp = Math.floor(Date.now() / 1000);
            const nonce = crypto.randomBytes(16).toString('hex');
            const signature = generateOAuth1Signature(timestamp, nonce);
            
            return `<?xml version="1.0" encoding="UTF-8"?>
          <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" 
                         xmlns:mes="urn:messages_2024_1.platform.webservices.netsuite.com" 
                         xmlns:core="urn:core_2024_1.platform.webservices.netsuite.com"
                         xmlns:plat="urn:core_2024_1.platform.webservices.netsuite.com">
            <soap:Header>
              <mes:tokenPassport>
                <core:account>${process.env.ACCOUNT_ID}</core:account>
                <core:consumerKey>${process.env.CONSUMER_KEY}</core:consumerKey>
                <core:token>${process.env.TOKEN_ID}</core:token>
                <core:nonce>${nonce}</core:nonce>
                <core:timestamp>${timestamp}</core:timestamp>
                <core:signature algorithm="HMAC-SHA256">${signature}</core:signature>
              </mes:tokenPassport>
            </soap:Header>
            <soap:Body>
              <mes:update>
                <mes:record xsi:type="plat:Script" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" internalId="${scriptId}">
                  <plat:scriptFile internalId="${fileId}"/>
                  <plat:apiVersion>${apiVersion}</plat:apiVersion>
                </mes:record>
              </mes:update>
            </soap:Body>
          </soap:Envelope>`;
          }

          // Find all JavaScript files recursively in a directory
          function findJavaScriptFiles(directory, fileList = [], relativePath = '') {
            if (!fs.existsSync(directory)) {
              return fileList;
            }
            
            const files = fs.readdirSync(directory);
            
            for (const file of files) {
              const fullPath = path.join(directory, file);
              const relPath = path.join(relativePath, file);
              
              if (fs.statSync(fullPath).isDirectory()) {
                // Recursively search subdirectories
                findJavaScriptFiles(fullPath, fileList, relPath);
              } else if (file.endsWith('.js') && file !== 'multiplier_netsuite_deployment.js') {
                // Add JavaScript files to the list with their relative paths
                fileList.push({
                  fullPath: fullPath,
                  relativePath: relativePath,
                  fileName: file
                });
              }
            }
            
            return fileList;
          }

          // Search for existing file in NetSuite File Cabinet
          async function findExistingFile(fileName, folderId) {
            const searchSOAP = generateSearchSOAP(fileName, folderId);

            try {
              const response = await axios.post(SOAP_URL, searchSOAP, {
                headers: {
                  'Content-Type': 'text/xml; charset=utf-8',
                  'SOAPAction': 'search'
                }
              });

              const fileIdMatch = response.data.match(/internalId="(\d+)"/);
              return fileIdMatch ? fileIdMatch[1] : null;
            } catch (err) {
              console.error('Error searching for file:', err.message);
              return null;
            }
          }

          // Search for existing script record in NetSuite
          async function findExistingScript(scriptName) {
            const searchSOAP = generateScriptSearchSOAP(scriptName);

            try {
              const response = await axios.post(SOAP_URL, searchSOAP, {
                headers: {
                  'Content-Type': 'text/xml; charset=utf-8',
                  'SOAPAction': 'search'
                }
              });

              const scriptIdMatch = response.data.match(/internalId="(\d+)"/);
              return scriptIdMatch ? scriptIdMatch[1] : null;
            } catch (err) {
              console.error('Error searching for script record:', err.message);
              return null;
            }
          }

          // Create or update script record
          async function createOrUpdateScriptRecord(fileId, fileName, fileContent) {
            try {
              // Parse script file to get script type and API version
              const { apiVersion, scriptType } = parseScriptFile(fileContent);
              
              if (!apiVersion || !scriptType) {
                console.log(`⚠️ Skipping script record creation for ${fileName}: Missing @NApiVersion or @NScriptType`);
                return {
                  success: false,
                  error: 'Missing script annotations',
                  fileName: fileName
                };
              }
              
              // Generate script name from file name (remove extension)
              const scriptName = path.basename(fileName, '.js');
              
              // Check if script record already exists
              const existingScriptId = await findExistingScript(scriptName);
              
              let response;
              let operation;
              
              if (existingScriptId) {
                // Update existing script record
                const updateSOAP = generateUpdateScriptSOAP(existingScriptId, scriptName, fileId, apiVersion);
                response = await axios.post(SOAP_URL, updateSOAP, {
                  headers: {
                    'Content-Type': 'text/xml; charset=utf-8',
                    'SOAPAction': 'update'
                  }
                });
                operation = 'Updated';
              } else {
                // Create new script record
                const addSOAP = generateAddScriptSOAP(scriptName, scriptType, fileId, apiVersion);
                response = await axios.post(SOAP_URL, addSOAP, {
                  headers: {
                    'Content-Type': 'text/xml; charset=utf-8',
                    'SOAPAction': 'add'
                  }
                });
                operation = 'Created';
              }
              
              // Parse response for script ID
              const scriptIdMatch = response.data.match(/internalId="(\d+)"/);
              if (!scriptIdMatch) {
                return {
                  success: false,
                  error: 'Could not parse script ID from response',
                  fileName: fileName
                };
              }
              
              return {
                success: true,
                scriptId: scriptIdMatch[1],
                scriptName: scriptName,
                scriptType: scriptType,
                operation: operation,
                fileName: fileName
              };
            } catch (err) {
              return {
                success: false,
                error: err.response?.data || err.message,
                fileName: fileName
              };
            }
          }

          // Upload single file with smart update/create logic
          async function uploadSingleFile(fileInfo, folderId) {
            const { fullPath, fileName } = fileInfo;
            
            try {
              const fileContent = fs.readFileSync(fullPath, 'utf8');
              const base64Content = Buffer.from(fileContent).toString('base64');

              // Check if file already exists
              const existingFileId = await findExistingFile(fileName, folderId);
              
              let soapEnvelope;
              let action;
              let operation;

              if (existingFileId) {
                // Update existing file
                soapEnvelope = generateUpdateSOAP(existingFileId, fileName, base64Content);
                action = 'update';
                operation = 'Updated';
              } else {
                // Create new file
                soapEnvelope = generateAddSOAP(fileName, base64Content, folderId);
                action = 'add';
                operation = 'Created';
              }

              const response = await axios.post(SOAP_URL, soapEnvelope, {
                headers: {
                  'Content-Type': 'text/xml; charset=utf-8',
                  'SOAPAction': action
                }
              });

              // Parse response for file ID
              let fileIdMatch = response.data.match(/internalId="(\d+)"/);
              if (!fileIdMatch) {
                fileIdMatch = response.data.match(/<platformCore:internalId>(\d+)<\/platformCore:internalId>/);
              }

              if (fileIdMatch) {
                const fileId = fileIdMatch[1];
                const result = {
                  success: true,
                  fileId: fileId,
                  fileName: fileName,
                  operation: operation,
                  filePath: fullPath
                };
                
                // Check if this is a script file with annotations and create/update script record
                if (fileName.endsWith('.js')) {
                  const scriptResult = await createOrUpdateScriptRecord(fileId, fileName, fileContent);
                  if (scriptResult.success) {
                    result.scriptId = scriptResult.scriptId;
                    result.scriptOperation = scriptResult.operation;
                    result.scriptType = scriptResult.scriptType;
                  }
                }
                
                return result;
              }
              
              return { 
                success: false, 
                error: 'Could not parse file ID from response',
                fileName: fileName,
                filePath: fullPath
              };
            } catch (err) {
              return { 
                success: false, 
                error: err.response?.data || err.message,
                fileName: fileName,
                filePath: fullPath
              };
            }
          }

          // Map GitHub folder path to NetSuite folder path
          function mapToNetSuiteFolderPath(githubFolderPath) {
            // Check if we have a direct mapping
            if (FOLDER_PATH_MAPPING[githubFolderPath]) {
              return FOLDER_PATH_MAPPING[githubFolderPath];
            }
            
            // If no direct mapping, try to construct one
            const parts = githubFolderPath.split('/');
            const suiteScriptsIndex = parts.indexOf('SuiteScripts');
            
            if (suiteScriptsIndex !== -1) {
              return 'SuiteScripts/' + parts.slice(suiteScriptsIndex + 1).join('/');
            }
            
            // Default to SuiteScripts root
            console.warn(`No folder mapping found for ${githubFolderPath}, using SuiteScripts root`);
            return 'SuiteScripts';
          }

          // Get folder ID for a specific path
          function getFolderIdForPath(netSuiteFolderPath) {
            // If we have a direct mapping, use it
            if (FOLDER_IDS[netSuiteFolderPath]) {
              return FOLDER_IDS[netSuiteFolderPath];
            }
            
            // If no direct mapping, use the SuiteScripts root folder ID
            console.warn(`No folder ID mapping found for ${netSuiteFolderPath}, using SuiteScripts root folder`);
            return FOLDER_IDS['SuiteScripts'];
          }

          // Upload all JavaScript files from directory to NetSuite
          async function uploadAllFiles(sourceRoot = SOURCE_ROOT) {
            // Check if directory exists
            if (!fs.existsSync(sourceRoot)) {
              console.error(`Root directory not found: ${sourceRoot}`);
              return [];
            }
            
            // Find all JavaScript files recursively
            const jsFiles = findJavaScriptFiles(sourceRoot);

            if (jsFiles.length === 0) {
              console.log(`No JavaScript files found in ${sourceRoot} or its subdirectories`);
              return [];
            }

            console.log(`Found ${jsFiles.length} JavaScript files to process`);

            const results = [];
            let successCount = 0;
            let failureCount = 0;

            // Group files by their folder path for better organization
            const filesByFolder = {};
            for (const file of jsFiles) {
              const githubFolderPath = path.join(sourceRoot, file.relativePath);
              const netSuiteFolderPath = mapToNetSuiteFolderPath(githubFolderPath);
              
              if (!filesByFolder[netSuiteFolderPath]) {
                filesByFolder[netSuiteFolderPath] = [];
              }
              filesByFolder[netSuiteFolderPath].push(file);
            }

            // Process files folder by folder
            for (const netSuiteFolderPath in filesByFolder) {
              const files = filesByFolder[netSuiteFolderPath];
              const folderId = getFolderIdForPath(netSuiteFolderPath);
              
              console.log(`\nProcessing ${files.length} files for NetSuite folder: ${netSuiteFolderPath} (ID: ${folderId})`);
              
              for (const fileInfo of files) {
                const result = await uploadSingleFile(fileInfo, folderId);
                results.push(result);

                if (result.success) {
                  let message = `✅ ${result.operation}: ${result.fileName} (ID: ${result.fileId})`;
                  if (result.scriptId) {
                    message += ` → ${result.scriptOperation} script record (ID: ${result.scriptId}, Type: ${result.scriptType})`;
                  }
                  console.log(message);
                  successCount++;
                } else {
                  console.log(`❌ Failed: ${result.fileName} - ${result.error}`);
                  failureCount++;
                }

                // Rate limiting to avoid overwhelming NetSuite API
                await new Promise(resolve => setTimeout(resolve, 1000));
              }
            }

            console.log(`\nDeployment Summary: ${successCount} successful, ${failureCount} failed`);
            return results;
          }

          // Main function
          async function main() {
            try {
              console.log('Starting NetSuite deployment...');
              console.log(`Source root directory: ${SOURCE_ROOT}`);
              console.log('NetSuite folder ID mappings:');
              for (const [path, id] of Object.entries(FOLDER_IDS)) {
                console.log(`  ${path}: ${id}`);
              }
              
              await uploadAllFiles();
            } catch (error) {
              console.error('Deployment failed:', error);
              process.exit(1);
            }
          }

          // Run the main function
          main();
          EOF
      
      - name: Deploy to NetSuite
        run: |
          # Add debugging for script record creation without breaking syntax
          echo "Adding debug mode for script record creation"
          sed -i 's/console.log(`⚠️ Skipping script record creation/console.log(`DEBUG: ⚠️ Skipping script record creation/' multiplier_netsuite_deployment.js
          
          # Fix the function signature modification to avoid syntax errors
          sed -i '/async function createOrUpdateScriptRecord/i // Debug script record creation' multiplier_netsuite_deployment.js
          sed -i '/async function createOrUpdateScriptRecord/a console.log(`DEBUG: Attempting to create\/update script record for ${fileName}`);' multiplier_netsuite_deployment.js
          
          # Run the deployment script with verbose logging
          node multiplier_netsuite_deployment.js
        env:
          ACCOUNT_ID: ${{ secrets.NETSUITE_ACCOUNT_ID }}
          BASE_URL: ${{ secrets.NETSUITE_BASE_URL }}
          CONSUMER_KEY: ${{ secrets.NETSUITE_CONSUMER_KEY }}
          CONSUMER_SECRET: ${{ secrets.NETSUITE_CONSUMER_SECRET }}
          TOKEN_ID: ${{ secrets.NETSUITE_TOKEN_ID }}
          TOKEN_SECRET: ${{ secrets.NETSUITE_TOKEN_SECRET }}
          NETSUITE_SUITESCRIPTS_FOLDER_ID: ${{ secrets.NETSUITE_SUITESCRIPTS_FOLDER_ID }}
          NETSUITE_RESTLET_FOLDER_ID: '2747420'
          DEBUG: 'true'

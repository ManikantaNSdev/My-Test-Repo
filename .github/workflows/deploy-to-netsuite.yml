name: Deploy to NetSuite with JWT

on:
  push:
    branches: [main]
    paths:
      - 'SuiteScripts/**.js'  # Trigger on any JavaScript file changes in SuiteScripts folder or subfolders
      - '.github/workflows/deploy-to-netsuite.yml'  # Also trigger when workflow file changes
  workflow_dispatch:  # Allow manual triggering

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '16'
      
      - name: Create package.json if not exists
        run: |
          if [ ! -f package.json ]; then
            echo '{
              "name": "netsuite-deployment-automation",
              "version": "1.0.0",
              "dependencies": {
                "axios": "^1.9.0",
                "crypto": "^1.0.1",
                "dotenv": "^16.5.0",
                "form-data": "^4.0.3",
                "jsonwebtoken": "^9.0.2",
                "oauth-1.0a": "^2.2.6"
              }
            }' > package.json
          fi
      
      - name: Install dependencies
        run: npm install
      
      - name: Create deployment script
        run: |
          cat > multiplier_netsuite_deployment.js << 'EOF'
          /**
           * Multiplier NetSuite Deployment System
           * Syncs JavaScript files from GitHub to NetSuite while preserving folder structure
           */

          require('dotenv').config();
          const fs = require('fs');
          const axios = require('axios');
          const path = require('path');
          const crypto = require('crypto');

          // NetSuite API Configuration
          const BASE_URL = process.env.BASE_URL;
          const SOAP_URL = `${BASE_URL}/services/NetSuitePort_2024_1`;

          // Deployment Configuration
          const SOURCE_ROOT = './SuiteScripts';  // GitHub repo root folder for SuiteScripts
          
          // NetSuite folder IDs - can be configured via environment variables
          const FOLDER_IDS = {
            'SuiteScripts': process.env.NETSUITE_SUITESCRIPTS_FOLDER_ID || '2746719',
            'SuiteScripts/Restlet Scripts': process.env.NETSUITE_RESTLET_FOLDER_ID || '2746719',
            'SuiteScripts/Scheduled Scripts': process.env.NETSUITE_SCHEDULED_FOLDER_ID || '2746719',
            'SuiteScripts/MapReduce Scripts': process.env.NETSUITE_MAPREDUCE_FOLDER_ID || '2746719',
            'SuiteScripts/Suitelet Scripts': process.env.NETSUITE_SUITELET_FOLDER_ID || '2746719',
            // Add more folder mappings as needed
          };

          // Generate OAuth 1.0 signature for NetSuite Token-Based Authentication
          function generateOAuth1Signature(timestamp, nonce) {
            const baseString = `${process.env.ACCOUNT_ID}&${process.env.CONSUMER_KEY}&${process.env.TOKEN_ID}&${nonce}&${timestamp}`;
            const signingKey = `${process.env.CONSUMER_SECRET}&${process.env.TOKEN_SECRET}`;
            return crypto.createHmac('sha256', signingKey).update(baseString).digest('base64');
          }

          // Generate SOAP envelope to search for existing files
          function generateSearchSOAP(fileName, folderId) {
            const timestamp = Math.floor(Date.now() / 1000);
            const nonce = crypto.randomBytes(16).toString('hex');
            const signature = generateOAuth1Signature(timestamp, nonce);

            return `<?xml version="1.0" encoding="UTF-8"?>
          <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" 
                         xmlns:mes="urn:messages_2024_1.platform.webservices.netsuite.com" 
                         xmlns:core="urn:core_2024_1.platform.webservices.netsuite.com"
                         xmlns:fil="urn:filecabinet_2024_1.documents.webservices.netsuite.com">
            <soap:Header>
              <mes:tokenPassport>
                <core:account>${process.env.ACCOUNT_ID}</core:account>
                <core:consumerKey>${process.env.CONSUMER_KEY}</core:consumerKey>
                <core:token>${process.env.TOKEN_ID}</core:token>
                <core:nonce>${nonce}</core:nonce>
                <core:timestamp>${timestamp}</core:timestamp>
                <core:signature algorithm="HMAC-SHA256">${signature}</core:signature>
              </mes:tokenPassport>
            </soap:Header>
            <soap:Body>
              <mes:search>
                <mes:searchRecord xsi:type="fil:FileSearch" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                  <fil:basic>
                    <core:name operator="is">
                      <core:searchValue>${fileName}</core:searchValue>
                    </core:name>
                    <core:folder operator="anyOf">
                      <core:searchValue internalId="${folderId}"/>
                    </core:folder>
                  </fil:basic>
                </mes:searchRecord>
              </mes:search>
            </soap:Body>
          </soap:Envelope>`;
          }

          // Generate SOAP envelope for file upload (add)
          function generateAddSOAP(fileName, base64Content, folderId) {
            const timestamp = Math.floor(Date.now() / 1000);
            const nonce = crypto.randomBytes(16).toString('hex');
            const signature = generateOAuth1Signature(timestamp, nonce);

            return `<?xml version="1.0" encoding="UTF-8"?>
          <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" 
                         xmlns:mes="urn:messages_2024_1.platform.webservices.netsuite.com" 
                         xmlns:core="urn:core_2024_1.platform.webservices.netsuite.com"
                         xmlns:fil="urn:filecabinet_2024_1.documents.webservices.netsuite.com">
            <soap:Header>
              <mes:tokenPassport>
                <core:account>${process.env.ACCOUNT_ID}</core:account>
                <core:consumerKey>${process.env.CONSUMER_KEY}</core:consumerKey>
                <core:token>${process.env.TOKEN_ID}</core:token>
                <core:nonce>${nonce}</core:nonce>
                <core:timestamp>${timestamp}</core:timestamp>
                <core:signature algorithm="HMAC-SHA256">${signature}</core:signature>
              </mes:tokenPassport>
            </soap:Header>
            <soap:Body>
              <mes:add>
                <mes:record xsi:type="fil:File" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                  <fil:name>${fileName}</fil:name>
                  <fil:content>${base64Content}</fil:content>
                  <fil:fileType>_JAVASCRIPT</fil:fileType>
                  <fil:folder internalId="${folderId}"/>
                </mes:record>
              </mes:add>
            </soap:Body>
          </soap:Envelope>`;
          }

          // Generate SOAP envelope for file update
          function generateUpdateSOAP(fileId, fileName, base64Content) {
            const timestamp = Math.floor(Date.now() / 1000);
            const nonce = crypto.randomBytes(16).toString('hex');
            const signature = generateOAuth1Signature(timestamp, nonce);

            return `<?xml version="1.0" encoding="UTF-8"?>
          <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" 
                         xmlns:mes="urn:messages_2024_1.platform.webservices.netsuite.com" 
                         xmlns:core="urn:core_2024_1.platform.webservices.netsuite.com"
                         xmlns:fil="urn:filecabinet_2024_1.documents.webservices.netsuite.com">
            <soap:Header>
              <mes:tokenPassport>
                <core:account>${process.env.ACCOUNT_ID}</core:account>
                <core:consumerKey>${process.env.CONSUMER_KEY}</core:consumerKey>
                <core:token>${process.env.TOKEN_ID}</core:token>
                <core:nonce>${nonce}</core:nonce>
                <core:timestamp>${timestamp}</core:timestamp>
                <core:signature algorithm="HMAC-SHA256">${signature}</core:signature>
              </mes:tokenPassport>
            </soap:Header>
            <soap:Body>
              <mes:update>
                <mes:record xsi:type="fil:File" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" internalId="${fileId}">
                  <fil:name>${fileName}</fil:name>
                  <fil:content>${base64Content}</fil:content>
                  <fil:fileType>_JAVASCRIPT</fil:fileType>
                </mes:record>
              </mes:update>
            </soap:Body>
          </soap:Envelope>`;
          }

          // Find all JavaScript files recursively in a directory
          function findJavaScriptFiles(directory, fileList = [], relativePath = '') {
            if (!fs.existsSync(directory)) {
              return fileList;
            }
            
            const files = fs.readdirSync(directory);
            
            for (const file of files) {
              const fullPath = path.join(directory, file);
              const relPath = path.join(relativePath, file);
              
              if (fs.statSync(fullPath).isDirectory()) {
                // Recursively search subdirectories
                findJavaScriptFiles(fullPath, fileList, relPath);
              } else if (file.endsWith('.js') && file !== 'multiplier_netsuite_deployment.js') {
                // Add JavaScript files to the list with their relative paths
                fileList.push({
                  fullPath: fullPath,
                  relativePath: relativePath,
                  fileName: file
                });
              }
            }
            
            return fileList;
          }

          // Search for existing file in NetSuite File Cabinet
          async function findExistingFile(fileName, folderId) {
            const searchSOAP = generateSearchSOAP(fileName, folderId);

            try {
              const response = await axios.post(SOAP_URL, searchSOAP, {
                headers: {
                  'Content-Type': 'text/xml; charset=utf-8',
                  'SOAPAction': 'search'
                }
              });

              const fileIdMatch = response.data.match(/internalId="(\d+)"/);
              return fileIdMatch ? fileIdMatch[1] : null;
            } catch (err) {
              console.error('Error searching for file:', err.message);
              return null;
            }
          }

          // Upload single file with smart update/create logic
          async function uploadSingleFile(fileInfo, folderId) {
            const { fullPath, fileName } = fileInfo;
            
            try {
              const fileContent = fs.readFileSync(fullPath, 'utf8');
              const base64Content = Buffer.from(fileContent).toString('base64');

              // Check if file already exists
              const existingFileId = await findExistingFile(fileName, folderId);
              
              let soapEnvelope;
              let action;
              let operation;

              if (existingFileId) {
                // Update existing file
                soapEnvelope = generateUpdateSOAP(existingFileId, fileName, base64Content);
                action = 'update';
                operation = 'Updated';
              } else {
                // Create new file
                soapEnvelope = generateAddSOAP(fileName, base64Content, folderId);
                action = 'add';
                operation = 'Created';
              }

              const response = await axios.post(SOAP_URL, soapEnvelope, {
                headers: {
                  'Content-Type': 'text/xml; charset=utf-8',
                  'SOAPAction': action
                }
              });

              // Parse response for file ID
              let fileIdMatch = response.data.match(/internalId="(\d+)"/);
              if (!fileIdMatch) {
                fileIdMatch = response.data.match(/<platformCore:internalId>(\d+)<\/platformCore:internalId>/);
              }

              if (fileIdMatch) {
                return {
                  success: true,
                  fileId: fileIdMatch[1],
                  fileName: fileName,
                  operation: operation,
                  filePath: fullPath
                };
              }
              
              return { 
                success: false, 
                error: 'Could not parse file ID from response',
                fileName: fileName,
                filePath: fullPath
              };
            } catch (err) {
              return { 
                success: false, 
                error: err.response?.data || err.message,
                fileName: fileName,
                filePath: fullPath
              };
            }
          }

          // Get folder ID for a specific path, creating a default mapping if not found
          function getFolderIdForPath(folderPath) {
            // If we have a direct mapping, use it
            if (FOLDER_IDS[folderPath]) {
              return FOLDER_IDS[folderPath];
            }
            
            // If no direct mapping, use the SuiteScripts root folder ID
            console.warn(`No folder ID mapping found for ${folderPath}, using SuiteScripts root folder`);
            return FOLDER_IDS['SuiteScripts'];
          }

          // Upload all JavaScript files from directory to NetSuite
          async function uploadAllFiles(sourceRoot = SOURCE_ROOT) {
            // Check if directory exists
            if (!fs.existsSync(sourceRoot)) {
              console.error(`Root directory not found: ${sourceRoot}`);
              return [];
            }
            
            // Find all JavaScript files recursively
            const jsFiles = findJavaScriptFiles(sourceRoot);

            if (jsFiles.length === 0) {
              console.log(`No JavaScript files found in ${sourceRoot} or its subdirectories`);
              return [];
            }

            console.log(`Found ${jsFiles.length} JavaScript files to process`);

            const results = [];
            let successCount = 0;
            let failureCount = 0;

            // Group files by their folder path for better organization
            const filesByFolder = {};
            for (const file of jsFiles) {
              const folderPath = path.join('SuiteScripts', file.relativePath);
              if (!filesByFolder[folderPath]) {
                filesByFolder[folderPath] = [];
              }
              filesByFolder[folderPath].push(file);
            }

            // Process files folder by folder
            for (const folderPath in filesByFolder) {
              const files = filesByFolder[folderPath];
              const folderId = getFolderIdForPath(folderPath);
              
              console.log(`\nProcessing ${files.length} files in ${folderPath} (NetSuite Folder ID: ${folderId})`);
              
              for (const fileInfo of files) {
                const result = await uploadSingleFile(fileInfo, folderId);
                results.push(result);

                if (result.success) {
                  console.log(`✅ ${result.operation}: ${result.fileName} (ID: ${result.fileId})`);
                  successCount++;
                } else {
                  console.log(`❌ Failed: ${result.fileName} - ${result.error}`);
                  failureCount++;
                }

                // Rate limiting to avoid overwhelming NetSuite API
                await new Promise(resolve => setTimeout(resolve, 1000));
              }
            }

            console.log(`\nDeployment Summary: ${successCount} successful, ${failureCount} failed`);
            return results;
          }

          // Main function
          async function main() {
            try {
              console.log('Starting NetSuite deployment...');
              console.log(`Source root directory: ${SOURCE_ROOT}`);
              console.log('Folder ID mappings:');
              for (const [path, id] of Object.entries(FOLDER_IDS)) {
                console.log(`  ${path}: ${id}`);
              }
              
              await uploadAllFiles();
            } catch (error) {
              console.error('Deployment failed:', error);
              process.exit(1);
            }
          }

          // Run the main function
          main();
          EOF
      
      - name: Create SuiteScripts directory structure
        run: |
          mkdir -p "SuiteScripts/Restlet Scripts"
          mkdir -p "SuiteScripts/Scheduled Scripts"
          mkdir -p "SuiteScripts/MapReduce Scripts"
          mkdir -p "SuiteScripts/Suitelet Scripts"
      
      - name: Deploy to NetSuite
        run: node multiplier_netsuite_deployment.js
        env:
          ACCOUNT_ID: ${{ secrets.NETSUITE_ACCOUNT_ID }}
          BASE_URL: ${{ secrets.NETSUITE_BASE_URL }}
          CONSUMER_KEY: ${{ secrets.NETSUITE_CONSUMER_KEY }}
          CONSUMER_SECRET: ${{ secrets.NETSUITE_CONSUMER_SECRET }}
          TOKEN_ID: ${{ secrets.NETSUITE_TOKEN_ID }}
          TOKEN_SECRET: ${{ secrets.NETSUITE_TOKEN_SECRET }}
          NETSUITE_SUITESCRIPTS_FOLDER_ID: ${{ secrets.NETSUITE_SUITESCRIPTS_FOLDER_ID }}
          NETSUITE_RESTLET_FOLDER_ID: ${{ secrets.NETSUITE_RESTLET_FOLDER_ID }}
          NETSUITE_SCHEDULED_FOLDER_ID: ${{ secrets.NETSUITE_SCHEDULED_FOLDER_ID }}
          NETSUITE_MAPREDUCE_FOLDER_ID: ${{ secrets.NETSUITE_MAPREDUCE_FOLDER_ID }}
          NETSUITE_SUITELET_FOLDER_ID: ${{ secrets.NETSUITE_SUITELET_FOLDER_ID }}
          JWT_PRIVATE_KEY: ${{ secrets.NETSUITE_JWT_PRIVATE_KEY }}
          JWT_KEY_ID: ${{ secrets.NETSUITE_JWT_KEY_ID }}
